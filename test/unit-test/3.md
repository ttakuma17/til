## 課題3-1

[課題2](https://www.notion.so/2-ab782bceba3c45b8bcada7551abb2d8b?pvs=21)の単体テストを書くためには、依存性の注入とモック化を行う必要がありました。

そもそも、なぜ元の関数はカバレッジ100%のテストを書けなかったのでしょうか？
- DatabaseMockが直接newされているので、テスト実行時にモックできない
  - これによって、正常系と異常系の両方の分岐を網羅できない状態になってしまう
  - 例外を意図的に発生させることもできないので、常に100%網羅するテストがかけない
- NameApiServiceが直接newされているので、テスト実行時にモックできない
  - 外部APIに直接リクエストを送る形になるので、テストが安定しない
    - 通信に失敗するケース、レスポンスの内容が変わるなど
    - getFirstNameに`firstName.length > this.MAX_LENGTH`の条件があるが、この分岐を網羅するための設定をできなくなっているため

## 課題3-2

依存性の注入(Dependency Injection)とは何でしょうか？
- あるオブジェクトや関数が依存する、他のオブジェクトや関数を受け取るパターンのこと
  - 依存するオブジェクトを直接オブジェクトをnewする、直接関数を使用してしまうと、そのオブジェクトもしくは関数によって使用するオブジェクトが依存してしまう

どのような問題を解決するために考案されたのでしょうか？
- 実装が依存するオブジェクトや関数に密結合になってしまうことで、以下のような問題が発生する
  - 意図的に起こせない状態がでてくるので、テストが難しい
  - 再利用性が低いオブジェクトができてしまう
  - 依存クラスの変更が使用するクラスへも影響するので、変更に弱い
- 依存性の注入はこれらの課題を解決するために考えられたもの

参考
- [依存性の注入](https://ja.wikipedia.org/wiki/%E4%BE%9D%E5%AD%98%E6%80%A7%E3%81%AE%E6%B3%A8%E5%85%A5)
- [DI (依存性注入) って何のためにするのかわからない人向けに頑張って説明してみる](https://qiita.com/okazuki/items/a0f2fb0a63ca88340ff6)
- [DI って何でするのかわからない人向けに頑張って説明してみる「本来の意味」](https://qiita.com/okazuki/items/0c17a161a921847cd080)
- [世界一わかりやすいClean Architecture](https://www.nuits.jp/entry/easiest-clean-architecture-2019-09)
- [TypeScriptによるDependency Injection入門：DIコンテナを自作して内部構造を理解する](https://zenn.dev/spacemarket/articles/8ddba858aa09c2)

## 課題3-3

単体テストで外部との通信が発生することによるデメリット
- テストが壊れやすくなってしまい、メンテナンスが大変
  - 外部との通信では実行するタイミングで得られる結果が変わってしまうことが考えられる
    - 正常系、異常系という分類の中でも、正常系の中でもレスポンスが違うケースや、異常系でも通信エラー、外部通信を実行した結果得られるエラー
  - ↑の状態が変わることを考慮したテストを書く必要が出てくるが、予期しない状態を受け取るとテストに失敗してしまう

## 課題3-4 *任意

テストには「単体テスト」「統合テスト」など様々な分類や定義があります。
チーム内で「何を単体テストと呼ぶのか」「何を統合テストと呼ぶのか」など用語の定義集を作ってみても面白いかもしれません。

個人的にはテストサイズで考えたほうが、認識あわせやすい感覚はある
- https://logmi.jp/main/technology/330972
- どこまでを単体テストと呼ぶのかとかってずれるのあるあるだろうから

## 課題3-5

`sumOfArray`に空の配列を渡すと例外が発生します。あまり好ましい挙動ではありません。
なぜあまり好ましい挙動ではないのでしょうか？
- 空の配列を渡されうるのに、なんの考慮もされていないのが良くない
- `sumOfArray`という関数名から実行時のエラーは類推できるものでもない
- エラーが発生するとしても、なぜそのエラーが発生しているのか？がわかるようにしておかないと運用考えたときに辛い

「こうなるべきだ」とご自身が考える形にコードを修正してみてください。
- ここからやること

## 課題3-6

コードを修正したら、先ほど書いた単体テストが落ちるはずです。
全ての単体テストが通るよう、単体テストも修正してください。

## 課題3-7

単体テストを作成する際は、挙動が変わる境界値を検討したり、テストで保証しなければならない挙動を開発者自身が事前に考えておく必要があります。しかし複雑な機能をテストする場合あらかじめ全てのテストケースを開発者が想定しきることは難しいかもしれません。

「この特定の値の時だけ不具合が起きる」ケースを開発者が見落としてしまうと、テストケースが不完全になってしまいます。そんな時に役立つかもしれない概念として「Property Based Testing（プロパティベースのテスト）」があります（対照的な存在としてはExample Based Testingが挙げられます）。

なぜこのテストの考え方がコード品質を向上してくれる可能性があるのでしょうか？
逆に採用しない方が良いケースはあるのでしょうか？

## 課題3-8

単体テストケースを増やしても可読性、保守性、実行速度などに問題が起きないよう工夫できることを3つ考えてみましょう。

例: `arrange-act-assert`パターンを採用する、など

