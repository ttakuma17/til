### 課題1

#### Jest のドキュメントを読む
- https://jestjs.io/docs/ja/getting-started
- https://jestjs.io/docs/ja/using-matchers
- https://jestjs.io/docs/ja/asynchronous
- https://jestjs.io/docs/ja/setup-teardown
- https://jestjs.io/docs/ja/mock-functions
メモ
- jest は ESM(ECMA Script Module)のサポートはExperimental状態らしい
- CommonJSが前提となって生まれてるライブラリであることは理解しておきたい
- ブラウザがサポートしているのが、ESMだったり、Node.jsもESMサポートを始めているので、流れ的にはESMで対応していくほうが良さそう
- CommonJSは比較的古株らしい。
- で、ESMに対応してるテスト用のライブラリの1つがVitest。他にESM対応のテストライブラリがあるかは知らんけど、JestからVitestへの移行が進んでたりするらしい
  - VitestはJestを完全にサポートしていることをうたっているので移行も進めやすいとのこと

#### Vitestのドキュメントを読む
- https://vitest.dev/guide/
- https://vitest.dev/api/expect.html
- https://vitest.dev/api/expect.html#resolves
- https://vitest.dev/api/#setup-and-teardown
- https://vitest.dev/api/mock.html

### 課題2-1

まずは`sumOfArray`と`asyncSumOfArray`の単体テストを書いてみましょう。
様々なパターンのテストを書いてみましょう。
- https://github.com/ttakuma17/praha-challenge-templates/blob/0ea9952060852de8368aac3c83c6af947059c03b/jestSample/__tests__/functions.test.ts#L5

### 課題2-2

`asyncSumOfArraySometimesZero`と`getFirstNameThrowIfLong`の単体テストを書いてみましょう。こちらもテストカバレッジ100%を達成してください。

ただしこの2つの関数は、あまり良い書き方をされていないため、そのままだとテストカバレッジ100%を達成しつつ通過する単体テストは書けません。

単体テストを書けるように「依存性の注入」を使って`asyncSumOfArraySometimesZero`と`getFirstNameThrowIfLong`を書き直してみてください
- asyncSumOfArraySometimesZero
  - https://github.com/ttakuma17/praha-challenge-templates/blob/0ea9952060852de8368aac3c83c6af947059c03b/jestSample/functions.ts#L16
- getFirstNameThrowIfLong
  - https://github.com/ttakuma17/praha-challenge-templates/blob/0ea9952060852de8368aac3c83c6af947059c03b/jestSample/functions.ts#L30
- テスト
  - https://github.com/ttakuma17/praha-challenge-templates/blob/0ea9952060852de8368aac3c83c6af947059c03b/jestSample/__tests__/functions.test.ts#L35

### 課題2-3

`nameApiService.ts`の単体テストを書いてください。こちらもテストカバレッジ100%を達成してください
- https://github.com/ttakuma17/praha-challenge-templates/blob/0ea9952060852de8368aac3c83c6af947059c03b/jestSample/__tests__/functions.test.ts#L75

### 課題3-1

[課題2](https://www.notion.so/2-ab782bceba3c45b8bcada7551abb2d8b?pvs=21)の単体テストを書くためには、依存性の注入とモック化を行う必要がありました。

そもそも、なぜ元の関数はカバレッジ100%のテストを書けなかったのでしょうか？
- DatabaseMockが直接newされているので、テスト実行時にモックできない
  - これによって、正常系と異常系の両方の分岐を網羅できない状態になってしまう
  - 例外を意図的に発生させることもできないので、常に100%網羅するテストがかけない
- NameApiServiceが直接newされているので、テスト実行時にモックできない
  - 外部APIに直接リクエストを送る形になるので、テストが安定しない
    - 通信に失敗するケース、レスポンスの内容が変わるなど
    - getFirstNameに`firstName.length > this.MAX_LENGTH`の条件があるが、この分岐を網羅するための設定をできなくなっているため

### 課題3-2

依存性の注入(Dependency Injection)とは何でしょうか？
- あるオブジェクトや関数が依存する、他のオブジェクトや関数を受け取るパターンのこと
  - 依存するオブジェクトを直接オブジェクトをnewする、直接関数を使用してしまうと、そのオブジェクトもしくは関数によって使用するオブジェクトが依存してしまう

どのような問題を解決するために考案されたのでしょうか？
- 実装が依存するオブジェクトや関数に密結合になってしまうことで、以下のような問題が発生する
  - 意図的に起こせない状態がでてくるので、テストが難しい
  - 再利用性が低いオブジェクトができてしまう
  - 依存クラスの変更が使用するクラスへも影響するので、変更に弱い
- 依存性の注入はこれらの課題を解決するために考えられたもの

参考
- [依存性の注入](https://ja.wikipedia.org/wiki/%E4%BE%9D%E5%AD%98%E6%80%A7%E3%81%AE%E6%B3%A8%E5%85%A5)
- [DI (依存性注入) って何のためにするのかわからない人向けに頑張って説明してみる](https://qiita.com/okazuki/items/a0f2fb0a63ca88340ff6)
- [DI って何でするのかわからない人向けに頑張って説明してみる「本来の意味」](https://qiita.com/okazuki/items/0c17a161a921847cd080)
- [世界一わかりやすいClean Architecture](https://www.nuits.jp/entry/easiest-clean-architecture-2019-09)
- [TypeScriptによるDependency Injection入門：DIコンテナを自作して内部構造を理解する](https://zenn.dev/spacemarket/articles/8ddba858aa09c2)

### 課題3-3

単体テストで外部との通信が発生することによるデメリット
- テストが壊れやすくなってしまい、メンテナンスが大変
  - 外部との通信では実行するタイミングで得られる結果が変わってしまうことが考えられる
    - 正常系、異常系という分類の中でも、正常系の中でもレスポンスが違うケースや、異常系でも通信エラー、外部通信を実行した結果得られるエラー
  - ↑の状態が変わることを考慮したテストを書く必要が出てくるが、予期しない状態を受け取るとテストに失敗してしまう

### 課題3-4 *任意

テストには「単体テスト」「統合テスト」など様々な分類や定義があります。
チーム内で「何を単体テストと呼ぶのか」「何を統合テストと呼ぶのか」など用語の定義集を作ってみても面白いかもしれません。

個人的にはテストサイズで考えたほうが、認識あわせやすい感覚はある
- https://logmi.jp/main/technology/330972
- どこまでを単体テストと呼ぶのかとかってずれるのあるあるだろうから

### 課題3-5

`sumOfArray`に空の配列を渡すと例外が発生します。あまり好ましい挙動ではありません。
なぜあまり好ましい挙動ではないのでしょうか？
- 空の配列を渡されうるのに、なんの考慮もされていないのが良くない
- `sumOfArray`という関数名から実行時のエラーは類推できるものでもない
- エラーが発生するとしても、なぜそのエラーが発生しているのか？がわかるようにしておかないと運用考えたときに辛い

「こうなるべきだ」とご自身が考える形にコードを修正してみてください。
- https://github.com/ttakuma17/praha-challenge-templates/blob/7ce056649a14c82e10f74803a242eac3cd5f6c2c/jestSample/functions.ts#L5

### 課題3-6

コードを修正したら、先ほど書いた単体テストが落ちるはずです。
全ての単体テストが通るよう、単体テストも修正してください。
- https://github.com/ttakuma17/praha-challenge-templates/blob/7ce056649a14c82e10f74803a242eac3cd5f6c2c/jestSample/__tests__/functions.test.ts#L12
- https://github.com/ttakuma17/praha-challenge-templates/blob/7ce056649a14c82e10f74803a242eac3cd5f6c2c/jestSample/__tests__/functions.test.ts#L61

### 課題3-7
単体テストを作成する際は、挙動が変わる境界値を検討したり、テストで保証しなければならない挙動を開発者自身が事前に考えておく必要があります。しかし複雑な機能をテストする場合あらかじめ全てのテストケースを開発者が想定しきることは難しいかもしれません。

「この特定の値の時だけ不具合が起きる」ケースを開発者が見落としてしまうと、テストケースが不完全になってしまいます。そんな時に役立つかもしれない概念として「Property Based Testing（プロパティベースのテスト）」があります（対照的な存在としてはExample Based Testingが挙げられます）。

Example Based Testing と Property Based Testingの違い
- EBTは「こういう入力にはこれを返す」というテストをしていく方法
- PBTは「どんな入力であっても、この性質を満たす」というテストをしていく方法
- それぞれ、カバーできる範囲が違うことになる

なぜこのテストの考え方がコード品質を向上してくれる可能性があるのでしょうか？
- 開発者が想定できてなかった入力値をテストできる可能性は高まるので、それにより意図しないバグを検出できることで品質向上につながることがある
- 現実的に開発者が全パターンを網羅したテストケースを考えるのは能力的に不可能という前提で、網羅性の向上につながる
  - コンピューターでも完全網羅を担保するわけではないが、人間より間違いは少ない

逆に採用しない方が良いケースはあるのでしょうか？
- 境界値が単純、または、入力値が限られるもの(booleanしか入らないとか)は採用しないほうが良い
  - PBTにより生成されるテストケースが似通ったものになるが、テスト技法を正しく使うことで対応できるはず
  - 同じようなパターンのテストが生成されたとして、確かめられることが増えないのに、実行時間が増えるだけになるから
- バグの再現テストなどの具体的にパラメータが決まっているようなテスト
  - バグの再現→解消という最短で達成したい目的が決まっているのに、それ以外の値を考慮したテストをしても解消が遅れるだけになるから
  - バグの解消が終わったあとであれば、他に同様のバグが含まれていないかを確認する目的でテストケースを足すのは良いとは思う

参考
- https://speakerdeck.com/twada/intro-to-property-based-testing
- https://www.infoq.com/news/2023/07/property-based-testing/

### 課題3-8

単体テストケースを増やしても可読性、保守性、実行速度などに問題が起きないよう工夫できることを3つ考えてみましょう。

例: `arrange-act-assert`パターンを採用する、など

1. `arrange-act-assert`、`Four-Phase Test`など一般的によく知られているパターンを採用してテストケースを書く
2. テストサイズに則ってテストの配分を決める。Small > Medium > Largeの順で優先してテストを用意する
3. 意味のないテストケースを増やさない。Linter/Formatter、Compilerでチェックしてくれることをいちいちテストしないとか、設計上ロジックをかかないという判断をしたクラスにテストを書かないとか

参考
- https://speakerdeck.com/nihonbuson/readable-test-code
- https://speakerdeck.com/nihonbuson/tesutokodonihatesutofalseyi-tu-woip-meyou

### 課題4-1

内容は問いませんので、引数を受け取り、何らかの値を返却する関数を3つ作成してください。
- **作成した関数の単体テストをトリオのメンバーに書いてもらいましょう。**
- 関数には「外部APIとの通信」など、モックが必要になる仕組みを組み込むと、難易度が上がってなお良いでしょう！

1: 映画館の料金計算 
一般／2,000円
大学生(要学生証)／1,500円
高校生・中学生(要学生証)／1,000円
小人(3歳以上、一部作品は2歳以上)／1,000円
障がい者(付き添い2名様まで同料金、要手帳)／1,000円
レイトショー(20時以降に上映開始する作品)／1,500円
```typescript
type Category =
  | "general"
  | "university"
  | "highschool"
  | "child"
  | "disabled"
  | "late";

function calculateMovieFee(category: Category): number {
  switch (category) {
    case "general":
      return 2000;
    case "university":
      return 1500;
    case "highschool":
      return 1000;
    case "child":
      return 1000;
    case "disabled":
      return 1000;
    case "late":
      return 1500;
    default:
      throw new Error("Invalid category");
  }
}
```

2:　外部APIとの通信(https://dummyjson.com/docs/todos を使う)

Get All Carts
fetch('https://dummyjson.com/carts')
.then(res => res.json())
.then(console.log);
```
async function fetchAllCarts(): Promise<void> {
  try {
    const response = await fetch("https://dummyjson.com/carts");
    if (!response.ok) {
      throw new Error(`Failed to fetch carts: ${response.status}`);
    }
    const data = await response.json();
  } catch (error) {
    console.error("Error fetching carts:", error);
  }
}
```

3: 外部APIとの通信(https://openweathermap.org/ を使う)
https://pro.openweathermap.org/data/2.5/forecast/hourly?lat=44.34&lon=10.99&appid={API key} 
```
async function fetchHourlyForecast(apiKey: string): Promise<void> {
  const url = `https://pro.openweathermap.org/data/2.5/forecast/hourly?lat=44.34&lon=10.99&appid=${apiKey}`;
  try {
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(`Error fetching forecast: ${response.status}`);
    }
    const weatherData = await response.json();
    console.log(weatherData.list); // hourly forecastは list プロパティ内に格納される
  } catch (error) {
    console.error("Error fetching forecast:", error);
  }
}
```

### 課題4-2

jestに関する[クイズ](https://www.notion.so/0b1e9517d2a0444597b265308f93d87f?pvs=21)を作成してください。
- beforeEach と beforeAll の違いはなにか？
- 非同期関数( `fetchData()` は非同期でPromiseをresolveしたら `test`　を返す場合)をテストにするとき書き方は？
- jest.fn().mockReturnValueOnce(value) と jest.fn().mockImplementationOnce(fn) の主違いは何か？


### 課題5-1

JavaScriptやTypeScriptで書かれた任意のOSSライブラリを探して、そこに書かれているテストケースを覗いてみましょう。そこから新たに学んだことを最低でも3つ挙げてください。

- [Mastra](https://github.com/mastra-ai/mastra)
- [Dify](https://github.com/langgenius/dify)
- [aws-cdk](https://github.com/aws/aws-cdk)

新たに学んだこと
- https://github.com/mastra-ai/mastra/blob/main/packages/core/src/storage/test-utils/storage.ts
  - テスト実行前の準備の説明をコメントで書いていた。テストケースでの説明ができない箇所はなぜそのコードが存在するのかの説明を加えるのは理解しやすい
  - 一方で、コメント見なくても自明なこともあったので、そういうのはなくてもいいんじゃないかとは思う
- https://github.com/langgenius/dify/blob/main/api/tests/unit_tests/repositories/workflow_node_execution/test_sqlalchemy_repository.py
  - Arrange / Act / Assert のパターンでテストされてた。コメントとかで明示的には書いてないけど、やっぱりコードの可読性は高いように感じた
- https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-sqs/test/sqs.test.ts
  - Given / When / Then　のパターンでテストされている。difyのときも思ったが、テストコードの書き方に一貫性があるとわかりやすい
  - CloudFormationの生成内容で一致しているかのテストしている。モックしている様子もないけど、どうやってんのやろうは疑問

### 課題6-1 (任意課題)

TypeScriptに慣れたい方は、[こちらのTypeScript型問題集](https://github.com/type-challenges/type-challenges/blob/master/README.ja.md)に挑戦してみては如何でしょう？

TypeScriptには様々な型機能が用意されていますが、TypeScriptの全機能を公式ドキュメントで最初から最後まで読み解くより、実践的な問題を解きながら必要な知識を必要に応じて少しずつ体得していく方が効率的かもしれません。結構楽しいので、パズル感覚で楽しんでください！

今後もTypescriptをちゃんとつかうことになりそうだから、初級だけマスターしとく。中級以降は一旦パスする方針

むずかしい
- https://github.com/type-challenges/type-challenges/blob/main/questions/00898-easy-includes/README.ja.md
  - extends , in , readonly, インデックスアクセス
- https://github.com/type-challenges/type-challenges/blob/main/questions/00189-easy-awaited/README.ja.md
  - infer, PromiseLike

慣れてない気がする
- https://github.com/type-challenges/type-challenges/blob/main/questions/00004-easy-pick/README.ja.md
  - extends , keyof , in
- https://github.com/type-challenges/type-challenges/blob/main/questions/03312-easy-parameters/README.ja.md
  - infer, extends
- https://github.com/type-challenges/type-challenges/blob/main/questions/00014-easy-first/README.ja.md
  - extends, infer 型推論で取得
- https://github.com/type-challenges/type-challenges/blob/main/questions/00043-easy-exclude/README.ja.md
  - extend , never , 分配的条件条件付き型

ここまでは大丈夫
- https://github.com/type-challenges/type-challenges/blob/main/questions/00007-easy-readonly/README.ja.md
  - keyof, in
- https://github.com/type-challenges/type-challenges/blob/main/questions/00011-easy-tuple-to-object/README.ja.md
  - in , T[number]のインデックス型
- https://github.com/type-challenges/type-challenges/blob/main/questions/00018-easy-tuple-length/README.ja.md
  - length, readonly
- https://github.com/type-challenges/type-challenges/blob/main/questions/00268-easy-if/README.ja.md
  - extends
- https://github.com/type-challenges/type-challenges/blob/main/questions/00533-easy-concat/README.ja.md
  - extends, readonly
- https://github.com/type-challenges/type-challenges/blob/main/questions/03057-easy-push/README.ja.md
  - extends
- https://github.com/type-challenges/type-challenges/blob/main/questions/03060-easy-unshift/README.ja.md
  - extends

### まとめ

Conditional Types: 型を条件分岐して決めたいときに使う

```typescript
type MessageOf<T extends { message: unknown }> = T["message"];

interface Email {
    message: string;
}

type EmailMessageContents = MessageOf<Email>;
```

参考
- https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#conditional-type-constraints
- https://typescriptbook.jp/reference/statements/unknown

Distributive Conditional Types: Union型に対する条件はそれぞれに対して適用されて、結果もそれぞれに対して出される

```typescript
type ToArray<T> = T extends string ? T[] : never;
type StrArrOrNumArr = ToArray<string | number>; // string | never 
```

参考
- https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#distributive-conditional-types
- https://typescriptbook.jp/reference/statements/never

Inferring Within Conditional Types: 型の条件分岐内部で型推論してほしいときに使う  
inferはextends と組み合わせてつかうもの

```typescript
type GetReturnType<T> = T extends (...args: never[]) => infer R ? R : never;

type Num = GetReturnType<() => number>;
type Str = GetReturnType<() => string>;
type Bools = GetReturnType<(a: boolean, b: boolean) => boolean[]>;
type Never = GetReturnType<() => "never">;
```

参考
- https://typescriptbook.jp/reference/type-reuse/infer
- https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types

KeyOf Type Operator:オブジェクトの型を受け取って、そのキーの文字列か数値のUNION型を作る

```typescript
type Point = { x: number; y: number };
// keyof Point で型 Point のキー一覧（ユニオン型）を取り出す
type P = keyof Point; // "x" | "y"

type Arrayish = { [n: number]: unknown }
type A = keyof Arrayish; // number
```

keyofはオブジェクトの型からプロパティ名として返す型演算子

参考
- https://www.typescriptlang.org/docs/handbook/2/keyof-types.html
- https://typescriptbook.jp/reference/type-reuse/keyof-type-operator

Mapped Types: オブジェクトの型を受け取って、新しいオブジェクトの型を作る

```typescript
type OprionsFlags<T> = {
    [P in keyof T]: boolean;
}

type Features = {
    darkMode: () => void;
    newUserProfile: () => void;
}

type FetureOptions = OptionsFlags<Features>; // { darkMode: boolean; newUserProfile: boolean; }
```

基本的にUnion型と組み合わせて使うもの。Featuresのキーである darkMode と newUserProfileが keyofで取得されて、
P に取り出した値を型として定義する。

[K in Keys] がMapped Typeで各キーに対して、ループ処理回してるのと同じ。

参考
- https://www.typescriptlang.org/docs/handbook/2/mapped-types.html
- https://typescriptbook.jp/reference/type-reuse/mapped-types

Indexed Access Types: オブジェクトのプロパティの型を取得する

```typescript
type Person = {
    age: number;
    name: string;
}

// typeof オブジェクト[キー名]とすると値の型を取得できる
type Age = Person["age"]; // number

// typeof 配列[index]とすると配列の要素の型を取得できる
const arr = ["a", "b", "c"]
type A = typeof arr[0]; // string
```

### T[number] でTupleの中の各要素へアクセスして、Union型を作成する

そもそも、配列とタプルの性質として、インデックスはnumber型
```typescript
type T = [string, number, boolean];
// T[0] → string
// T[1] → number
// T[2] → boolean
```

よって、T[X]（X が number 型）で、全ての数値インデックスにアクセス可能

T[number] は、「number 型の任意のインデックスにアクセスしたとき得られる値の型すべて」のユニオン型になる

```typescript
// [string, number, boolean] において
// T[0] → string
// T[1] → number
// T[2] → boolean
// ⇒ T[number] = string | number | boolean
```

```typescript
const directions = ['up', 'down', 'left', 'right'] as const;
type Direction = typeof directions[number];
// => 'up' | 'down' | 'left' | 'right'
```

直感的に理解できるようにまとめると、
```typescript
type T = [A, B, C];
type T[number] = A | B | C;
```

### T[length]で tupleのサイズを取得する
```typescript
type Tuple = ['a', 'b', 'c'];
type Size = Tuple['length']; // これでサイズが取れる。TS コンパイラが推論してサイズを取得できる。
```

参考
- https://www.typescriptlang.org/docs/handbook/2/indexed-access-types.html

Types Challenge
- https://github.com/type-challenges/type-challenges/blob/main/README.ja.md
