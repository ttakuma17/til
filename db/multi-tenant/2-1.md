課題2-1
- テナント毎にデータベースを分割する(Silo)
  - メリット
    - データを完全に分離できている
    - テナント毎のカスタマイズができる
    - テナント毎のスケーリングできる
  - デメリット
    - インフラコストが高い
    - 運用が複雑になる
      - DBサーバ数 = テナント数になり、インフラリソースが増える
- テナント毎にスキーマを分割する(Bridge)
  - メリット
    - Siloよりインフラコストの削減
    - テナント毎のスキーマカスタマイズができる
  - デメリット
    - データベースサーバーの共有によるパフォーマンスリスク
    - スキーマ管理が複雑になる
    - スケーリングにサーバー単位という制限生まれる
- すべてのテナントで同じスキーマを使う(Pool)
  - メリット
    - インフラコストはSilo、Bridgeと比較して最安
    - リソースの効率的な使用
  - デメリット
    - データ分離レベルが低い
    - テナント毎のカスタマイズが困難
    - 大規模テナントの影響を受けやすくなる

- SiloとBridge
  - テーブル変更 → テナントの数 * ALTER
  - テーブル変更 → テナントの数 * CREATE
  - テナントが増えるとDBに変更・追加が必要なリソースの時間が伸びる
  - デプロイ、ロールバックは複雑なうえ、監視対象はテナント数だけ増える
- BridgeとPool
  - 突然のテーブルロック→サービス障害
    - 共有データベース環境では、一つのテナントの大規模な更新処理やスキーマ変更により、
      テーブルロックが発生し、他のテナントのサービスにも影響を及ぼす
      - 大量データの一括更新、ALTER TABLE実行
  - ホットスポット問題
    - 特定のテナントやデータ領域へのアクセスが集中することで発生する性能低下
      - 特定テナントの利用が急増した場合のI/O集中
      - 共有テーブルでの特定レコードへの頻繁なアクセス
      - インデックスの競合による更新遅延
  - 特定のユーザーの利用が他のユーザーへも影響を与えうる
    - 大規模なテナントがあって、そのテナントでDBのリソースを食い尽くしてしまうなど

課題2-2
- Row Level Security と マルチテナントアーキテクチャの実装方法
  - Row Level Security (RLS)
    - 概要
      - データベースレベルでの行単位のアクセス制御機能
      - テーブルの各行に対して、ユーザーごとのアクセス権限を定義
    - 実装方法
      - PostgreSQL
        https://www.postgresql.org/docs/current/sql-createpolicy.html
        ```sql
        -- テーブル作成
        CREATE TABLE tenant_data (
          id SERIAL PRIMARY KEY,
          tenant_id INTEGER,
          data TEXT
        );

        -- ポリシー作成
        CREATE POLICY tenant_isolation_policy ON tenant_data
          FOR ALL
          USING (tenant_id = current_setting('app.current_tenant_id')::INTEGER);

        -- RLS有効化
        ALTER TABLE tenant_data ENABLE ROW LEVEL SECURITY;
        ```
      - RLS設定 - 2種類
        - 実行時のパラメータでふりわける 
          - セッション変数の設定：`SET app.current_tenant_id = '1';`
          - トランザクション開始時にテナントIDを設定
          - アプリケーションのレベルで制御する方法
        - DBのRole名でふりわける
          - テナントごとにRoleを割り当ててSQLを実行させる方法
          - DBレベルで制御する方法
        