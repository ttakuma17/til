課題1-1
Check
- 一部のキャリアなどである「RFC 5321」の仕様に沿っていないメールアドレスなども含めて正規表現でCheck制約かけれるならつけてもよい
- フロントエンドでバリデーション、バックエンドでバリデーションをかけてるなら、DBでCheck制約までかけるかどうか？というのは考えどころになる。
- なので、使うべきとは判断できない。
Trigger
- トランザクションでDELETEとINSERTをトランザクション境界を区切っている、アプリケーション側でエラーハンドリングをしたいなら不要。
- アプリケーション側でトランザクションを区切りたくない場合、かつ、アプリケーションで実装することで漏れが出ることが懸念であれば、使っても良いと考えられそう。
- Triggerのほうが更新漏れを確実になくせるというのはメリットになるのでそれを優先する場合に使うことを検討できる。
Enum
- 仕様が変わったときにマイグレーションしないと行けなくなるので基本使わなくても良いと考える。アプリケーション側でEnumをつかってINSERTすれば良い。
- DB側で絶対に値のチェックをしないといけないという要件の開発でなければ基本不要。変更をするのに余計なコストになる。ORM対応してる？とかも判断基準にはなる。
- アプリケーションの仕様として、絶対に変わらないとかっていうのが確約できるなら使う判断するけど、そんなアプリケーションないから使いたい理由が見つからない
Domain
- 基本使わなくてよいと判断する。ほぼEnumと同じ理由。テーブルに対して固有機能で制限をかけすぎると、テーブルの変更コストが高くなる。
- DBを移行したいとなったときにもDBMSごとにサポートしているかが変わる機能は移行コストを上げることになるので使うべきではない。

アプリケーション側で課すアプローチ
- ビジネスロジックをになるような制約はアプリケーション側で制約を課すほうが良いと考える。
- ソースコードを見ることで、ビジネスロジックがわかるようになるし、ロジックがアプリケーションに集中していることで運用コストも下がる。
- ロジックがいろんな場所に散らばっていると、不要な驚きを生むことになる。
データベース側で制約を課すアプローチ
- ビジネスロジックにならない制約(DB側だけで完結するような内容）はデータベース側で制約をつければ良い
- テーブルのリファクタリングをする際にTriggerを使うなど。DBの存在自体がアプリケーションと同じ役目を果たしている場合もDB側で制約をかけるべき。利用者がDBを専用で持っていて、SQLやインポートなどでしか更新されないようなものであれば、DB側で制約をかけないと、いろんなデータが入り放題になってしまう。
