課題1-1

# ナイーブツリーのアンチパターンに関する整理

## 1. 前提
- ツリー構造のデータをデータベースで管理する際の設計について考える。
- 特に、直近の親のみを参照してツリー構造を表現する方法の問題点を整理する。

## 2. アンチパターンの名前
- **ナイーブツリー（Naive Tree）**
  - ツリー構造を表現する際に、各ノードが直近の親ノードのみを持つ設計。

## 3. アンチパターンによる問題
### SQLが複雑になり、パフォーマンスが低下する
- ツリー構造を取得するために **自己結合を繰り返す** 必要があり、SQLが複雑化する。
- スレッドの数 = 自己結合の数 となるため、スレッド数が増えると SQL の実行時間も増加する。

### 更新・削除時の負荷
- `UPDATE` や `DELETE` の際に、どのスレッドに対する処理かを特定するための `SELECT` が必要。
- スレッド数が増えると、処理の実行時間も比例して増加する。

### 階層の深さに依存したパフォーマンス低下
- 階層の数 = `JOIN` の数 となるため、深いツリー構造では SQL のパフォーマンスが著しく低下する。

## 4. アンチパターンを解消する方法
### 1. 経路列挙（Path Enumeration）
- ノードのパスを `/` 区切りなどで格納する方法。
- しかし、**ジェイウォークパターン（Jaywalking Pattern）** に当てはまりやすい（LIKE検索や文字列処理が発生するため、パフォーマンスが悪化）。

### 2. 入れ子集合（Nested Set）
- ツリー構造を **範囲（left, right）** で管理する方法。
- 取得時は効率的だが、ノードの挿入や削除時に大規模な更新が発生する点がデメリット。

### 3. 閉包テーブル（Closure Table）
- **親子関係を別のテーブルで管理する** 方法。
- ツリーの走査が高速で、`SELECT` 時のパフォーマンスが向上する。
- `INSERT` 時に少し処理が増えるが、最も柔軟でスケーラブルな解決策とされる。

## 5. 参考文献
- https://note.com/standenglish/n/n0f11205f154e
- https://qiita.com/fktnkit/items/57033c10b41b5747dbea
- https://ryo-ux-it-agile.com/naive-tree/
- https://zenn.dev/rescuenow/articles/c7d7291f2deed8
