### 課題3
問題点
- どの呼び出し元からでもPersonクラスやCompanyクラスのプロパティの値が変えられるので、どのタイミングで変わったかを後で探す手間が増えたりする（コードリーディングが大変）、変更できる前提でみると、どこで変えるべきなのかという考えをいちいちコード書いてる間に考えないといけない（設計思想がわからないので、変更速度が遅れる）
- 知らない間に値が変わっていたということで、別の箇所でバグが発生する可能性がある
　- 変更した箇所以外には、影響はないだろうって思ってたら、違うとこでその値を参照してて、バグになる可能性もある
- getter/setterを追加した場合もどこからでもクラスのプロパティを自由に変更できるという性質が変わらないので、↑にあげた問題を解決しない

解決方法
- クラスのプロパティの値をprivateにする
- 値の更新時には新しいオブジェクトを返すようにする

```typescript
// イミュータブルなPersonクラス
class Person {
    private readonly _name: string;
    private readonly _startWorkingAt: Date;

    constructor(name: string, startWorkingAt: Date) {
        this._name = name;
        // Dateオブジェクトのコピーを作成して保持
        this._startWorkingAt = new Date(startWorkingAt);
    }

    // 読み取り専用のアクセサ
    get name(): string {
        return this._name;
    }

    get startWorkingAt(): Date {
        // 新しいDateオブジェクトを返すことで、外部からの変更を防止
        return new Date(this._startWorkingAt);
    }

    // 新しいPersonインスタンスを返すメソッド
    withName(newName: string): Person {
        return new Person(newName, this._startWorkingAt);
    }

    withStartWorkingAt(newDate: Date): Person {
        return new Person(this._name, newDate);
    }
}

// イミュータブルなCompanyクラス
class Company {
    private readonly _people: readonly Person[];

    constructor(people: Person[]) {
        // 配列のコピーを作成して保持
        this._people = [...people];
    }

    get people(): readonly Person[] {
        // 配列のコピーを返すことで、外部からの変更を防止
        return [...this._people];
    }

    // 新しいCompanyインスタンスを返すメソッド
    withPerson(index: number, newPerson: Person): Company {
        const newPeople = [...this._people];
        newPeople[index] = newPerson;
        return new Company(newPeople);
    }
}

// 使用例
const company = new Company([
    new Person('a', new Date('2021-01-01')),
    new Person('b', new Date('2021-01-01'))
]);

// 値の取得
const firstPerson = company.people[0];
const startDate = firstPerson.startWorkingAt;

// 値の変更を試みる
startDate.setFullYear(1000); // 元のDateオブジェクトは変更されない
console.log(firstPerson.startWorkingAt); // 元の値が保持されている

// 正しい値の変更方法
const updatedPerson = firstPerson.withName('modified name');
const updatedCompany = company.withPerson(0, updatedPerson);

console.log(company.people[0].name); // 'a'のまま
console.log(updatedCompany.people[0].name); // 'modified name'
```

### メモ
- データをイミュータブルにするアプローチで解決する
- カプセル化
  - データとロジックを1つのクラスに閉じ込めて、そのクラスで責務を果たせるようにすること