### 課題2

- このコードにはどのような問題点が潜んでいるでしょうか？
  - 購入のたびに過去の購入履歴をSELECTしているのが、購入回数の多いユーザーほど対象データがおおくなり、パフォーマンスが悪くなる可能性がある
    - 購入テーブルはサイズが大きくなることが考えられるので、クエリ自体も重たくなり、テーブルロック問題なども発生するかもしれない
    そもそも、過去1年間の購入履歴しか取得する必要がないのに、あるユーザーの全件取得はやり過ぎ感もある
  - purchaseメソッドの引数が型安全ではない
    - userIdとproductIdが入れ替わって指定してもstringである限り気付けない
  - トランザクションの境界がわからないこと
    - SELECT、INSERTの流れだが、何らかの事情でSELECTが失敗してINSERTが可能な状態などになったときにロールバックされないように見えること
- もしあなたが書き換えるとしたら、どのようにこのコードを改修しますか？
  - SQL側で検索条件を指定するようにする
    - SQLにわたす検索期間は実行時に指定できるようにして、仕様の変更時や別の箇所で似たようなクエリを使いたい場合は、パラメータの変更で対応できるようにする


```typescript
// 型定義
interface Purchase {
    userId: string;
    productId: string;
    transaction: {
        succeeded: boolean;
        completedAt: Date;
    };
}

// 検索条件の型定義
interface PurchaseSearchCriteria {
    userId: string;
    startDate?: Date;
    endDate?: Date;
    productId?: string;
}

// リポジトリインターフェースの改善
interface PaymentRecordRepository {
    findPurchases(criteria: PurchaseSearchCriteria): Promise<Purchase[]>;
    savePurchase(purchase: Purchase): Promise<void>;
}

// エラー定義
class DuplicatePurchaseError extends Error {
    constructor(productId: string) {
        super(`この商品（${productId}）はおひとりさま一品限定です！`);
        this.name = 'DuplicatePurchaseError';
    }
}

// サービスクラスの改善
class PurchaseService {
    constructor(
        private readonly paymentRecordRepo: PaymentRecordRepository,
        private readonly dateRange: { startDate: Date; endDate: Date } = {
            startDate: new Date(Date.now() - 365 * 24 * 60 * 60 * 1000), // 1年前
            endDate: new Date()
        }
    ) {}

    public async purchase(userId: string, productId: string): Promise<void> {
        try {
            // 過去1年間の購入履歴のみを取得
            const recentPurchases = await this.paymentRecordRepo.findPurchases({
                userId,
                productId,
                startDate: this.dateRange.startDate,
                endDate: this.dateRange.endDate
            });

            const hasPurchased = recentPurchases.some(
                purchase => purchase.transaction.succeeded
            );

            if (hasPurchased) {
                throw new DuplicatePurchaseError(productId);
            }

            // 購入処理
            const newPurchase: Purchase = {
                userId,
                productId,
                transaction: {
                    succeeded: true,
                    completedAt: new Date()
                }
            };

            await this.paymentRecordRepo.savePurchase(newPurchase);
        } catch (error) {
            if (error instanceof DuplicatePurchaseError) {
                throw error;
            }
            throw new Error('購入処理中にエラーが発生しました');
        }
    }
}

// リポジトリの実装例
class SQLPaymentRecordRepository implements PaymentRecordRepository {
    async findPurchases(criteria: PurchaseSearchCriteria): Promise<Purchase[]> {
        // SQLクエリの構築
        const query = `
            SELECT * FROM purchases
            WHERE user_id = $1
            AND completed_at BETWEEN $2 AND $3
            ${criteria.productId ? 'AND product_id = $4' : ''}
        `;

        // 実際のデータベースクエリ実行
        // この部分は実際のデータベースライブラリに依存
        return [];
    }

    async savePurchase(purchase: Purchase): Promise<void> {
        // 実際のデータベース保存処理
    }
}

// 使用例
async function main() {
    const repository = new SQLPaymentRecordRepository();
    const service = new PurchaseService(repository);

    try {
        await service.purchase('user123', 'product456');
        console.log('購入が完了しました');
    } catch (error) {
        if (error instanceof DuplicatePurchaseError) {
            console.error(error.message);
        } else {
            console.error('予期せぬエラーが発生しました');
        }
    }
}
```