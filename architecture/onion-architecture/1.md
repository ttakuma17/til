### 課題1-1

オニオンアーキテクチャを図解してください。その際、以下の概念を必ず含めてください。

- ドメインモデル
- ドメインサービス
- インフラ
- ユーザインターフェース

- ![図解](./onion-architecture.png)


### 課題1-2

中心に位置するドメインモデル層は他のどの層にも依存していません。こうすることに、どのようなメリットがあるのでしょうか？

- ドメインモデルの変更が他の層に依存しないことがメリット
  - 前提として、ビジネスロジックは状況によってよく変わりうるもの
  - ビジネスロジックの変更が理由で、他の層への変更が伝搬しないことで、修正箇所を最小限にできる

### 課題1-3

層をまたいで依存関係が発生する時（例えばユースケース層がレポジトリ層のメソッドを呼び出す時など）はインターフェースに対する依存のみ許可します。こうすることに、どのようなメリットがあるのでしょうか？

- 実装(今回はレポジトリ層のメソッド)が変わったとしても、インターフェースが変わらない限り、呼び出し側の変更は不要になる
- レポジトリのメソッドが大幅に変わったとしても同じで、RDB→NoSQLに変えたとしても、呼び出し側へその変更が依存しないことを確約できること  
- テストが容易になること

```typescript
// インターフェースを使用したテスト容易な実装
interface OrderRepository {
    save(order: Order): Promise<void>;
    findById(id: string): Promise<Order>;
}

// モックを使用したテスト
class MockOrderRepository implements OrderRepository {
    private orders: Order[] = [];

    async save(order: Order): Promise<void> {
        this.orders.push(order);
    }

    async findById(id: string): Promise<Order> {
        return this.orders.find(o => o.id === id);
    }
}
```

### 課題1-4

「依存性の逆転」がオニオンアーキテクチャにおいてどのように使われているのか説明してください

- オニオンアーキテクチャの生まれた背景から考える
  - レイヤードアーキテクチャ
    - UI → Application →　Domain → Infrastructure
    - このようにDomainクラスがInfrastructureに依存している。が、Infrastructureの変更がDomain層に影響してしまうことを問題と捉えている
    - ビジネス的に考えると一番重要なレイヤーはDomainが、ビジネス的には興味のないInfrastructureに依存しているのが問題
- オニオンアーキテクチャでは、Infrastructure層の依存Domain層に向けるときに、依存性の逆転をつかっている

- ![図解](./dependency-diagram.png) 
    
### 課題1-5

特定のユーザにしかリソースの追加や更新を許さないようなアクセス制限機能を実装したいとします。どの層に記述するのが適切でしょうか？（これは開発者によって意見が割れると思いますので、様々な観点から根拠を集めてみてください！）
 
- アプリケーションサービス層
  - アクセス制限をシステム的な権限管理と捉えるなら、ビジネスロジックではないので、ドメイン層にはいるのはおかしいから、アプリケーションサービス層に書くべきと言えそう

- ドメインサービス層
  - アクセス制限によって売上が変わるなどであれば、ドメインサービス層に書くべきものになると考えられそう
    - Free、Pro、Enterpriseっていう3つのUserがあって、それによって料金もできることも違うという機能を提供しているなら、アクセス制御はドメインサービス層にあるべきだと思う

```typescript
// ドメインサービスの例
class OrderDomainService {
    validateOrder(order: Order): boolean {
        // ドメインのルールに基づく検証
        return order.items.length > 0 && order.totalAmount > 0;
    }
}

// アプリケーションサービスの例
class OrderApplicationService {
    constructor(
        private orderRepository: OrderRepository,
        private paymentGateway: PaymentGateway
    ) {}

    async processOrder(order: Order): Promise<void> {
        // トランザクション管理や外部サービスとの連携
        await this.orderRepository.save(order);
        await this.paymentGateway.processPayment(order);
    }
}
```

### 課題1-6

データベースをMySQLからPostgreSQLに変更するとします。どの層を変更する必要があるでしょうか？

- インフラ層
  - データベースはアプリケーションから見ると、外部のリソースでビジネスロジックに直接関係あるものでもない

### 参考
- [オニオンアーキテクチャで実現した 本質課題を解決する インフラ移行の実例](https://speakerdeck.com/hryushm/onion-architecture-infrastructure-migration)
- [ドメイン駆動設計(DDD)・オニオンアーキテクチャとは？](https://qiita.com/k_yamaki/items/bf99d3bf64a84258a3a1)
- [オニオンアーキテクチャとは何か](https://qiita.com/cocoa-maemae/items/e3f2eabbe0877c2af8d0)
- [クリーンアーキわからんかった人のためのオニオンアーキテクチャ](https://zenn.dev/streamwest1629/articles/no-clean_hello-onion-architecture)
- [Onion Architecture](https://medium.com/expedia-group-tech/onion-architecture-deed8a554423)

### メモ

- ドメインサービスとアプリケーションサービスの違いってなんやろ
  - [混乱しがちなサービスという概念について](https://blog.j5ik2o.me/entry/2016/03/07/034646)
  - ドメインサービス
    - ドメインのルールやビジネスロジックを実装する層。ビジネス以外の要素で実行、分割される理由がないロジックをここで表現する。ドメインモデルの操作、複数エンティティにまたがる処理、ビジネスロジックなど
    - ドメインサービスが依存するのはドメインモデルだけ
```typescript
// ドメインサービスの例
class OrderDomainService {
    // 注文の検証ルール
    validateOrder(order: Order): boolean {
        // ドメインのルールに基づく検証
        return this.validateStock(order) && 
               this.validatePrice(order) && 
               this.validateUserStatus(order);
    }

    // 在庫の検証
    private validateStock(order: Order): boolean {
        return order.items.every(item => 
            item.product.stock >= item.quantity
        );
    }

    // 価格の検証
    private validatePrice(order: Order): boolean {
        return order.totalAmount > 0 && 
               order.totalAmount <= order.user.maxOrderAmount;
    }

    // ユーザーステータスの検証
    private validateUserStatus(order: Order): boolean {
        return order.user.status === 'active' && 
               !order.user.isBlacklisted;
    }
}
```
  - アプリケーションサービス
    - アプリケーションサービスは、ユースケースの実装や外部サービスとの連携を担当する層。ビジネスルールに紐づかない処理をここで表現する。DBへのデータの保存、キューへメッセージ詰めるなど。
    - アプリケーションサービスが依存するのは、複数の層でリポジトリ、外部サービス、ドメインサービスなどになる

```typescript
// アプリケーションサービスの例
class OrderApplicationService {
    constructor(
        private orderRepository: OrderRepository,
        private paymentGateway: PaymentGateway,
        private emailService: EmailService,
        private orderDomainService: OrderDomainService
    ) {}

    // 注文処理のユースケース
    async processOrder(order: Order): Promise<void> {
        try {
            // 1. ドメインルールの検証
            if (!this.orderDomainService.validateOrder(order)) {
                throw new Error('Invalid order');
            }

            // 2. トランザクションの開始
            await this.orderRepository.beginTransaction();

            // 3. 支払い処理
            const paymentResult = await this.paymentGateway.processPayment({
                amount: order.totalAmount,
                currency: 'JPY',
                customerId: order.user.id
            });

            // 4. 注文の保存
            await this.orderRepository.save(order);

            // 5. 在庫の更新
            await this.updateInventory(order);

            // 6. メール送信
            await this.emailService.sendOrderConfirmation(order);

            // 7. トランザクションのコミット
            await this.orderRepository.commit();
        } catch (error) {
            // 8. エラー時のロールバック
            await this.orderRepository.rollback();
            throw error;
        }
    }

    private async updateInventory(order: Order): Promise<void> {
        // 在庫更新のロジック
    }
}
```
- とはいえ、アプリケーションサービスとドメインサービスで迷うくらいならわけるながベースとしてあるらしい