## 課題2

### 課題2-1

境界づけられたコンテキストの実例を一つ挙げてください。

- 商品というユビキタス言語を定義していた場合に、マーケティングの部署では商品のことを販売した商品、物流の部署では商品のことを在庫という言葉を使っていた場合、同じ商品だとしても違う意味を持っていることになる

### 課題2-2

以下のプロパティを持つ「Human」エンティティを作成してください。

- 識別子(ID)
- 血液型
- 生年月日
- 名前

```typescript
class Human {
    constructor(
        public readonly _id: string,
        public _bloodType: string,
        public _dateOfBirth: string,
        public _name: string
    ){}
}
```

### 課題2-3

上記のHumanモデリングを担当した新人エンジニアからこんな事を聞かれました。

Humanクラスを設計しろと言われたので[こんなコード](https://www.typescriptlang.org/play?#code/MYGwhgzhAEASCuBbMA7aBvAUNH1gHsUIAXAJ3mGP1IAoAHeAIxAEthpSBTMAE0JACe0FjwBc0EqRYoA5gBpoDZmw7c+KQdGb58PYgLqdxk6fMVNW7Lr35DGLUsQAWPMMSPQAIm84Kll1RsNIRQwRA8TWQBKDGxceJYAM2gaAEJnFggAOgA3MFYeAAVSfDoIGnQROW1dfUNqh2dXdzlQ8IBfKJj0aGcSgHdoFE5BgFFSEtoAcmk8gsUSuimY9ricVbWFljz3aDmRYtLyukWIcUqxCTJTBRq9Awjr2VvGlx9xbxahsMepWU7xIwdCBuGgsPF4lxiPBSGgMtl9jwAJI8einLIiGIAMixvScmVy+REACEQDp7oY0Ucsnc6pxsbj4YSCsTXs1OFSyjS2T4GXiCYiAHI-TnZNr0zareInbY+PZE5GoubwX6mKKiIH4EGoDDQAD0ACpoIBIc0AnUqAKwYkZ5AOYMgCEGQDRDIBouUAdgyABYZAFcMgHGGQA-DIB2hkA5wyAZ4ZAEkMgBkIwBiDNADXrVNDYb1yJxoFLcDKdknEaTyXSaMrVdENcDQbrDSaLYABCMATbaAaPU7U63V6-UGw5Ho7GYXDE8nNmm5Zmee4aPZHG93B9eYWtcWeqWzebAPiugBc9QAQ5oBT0zrLo9PoDIYjUZjUI7CZV3elUnT8oKwvCNHFxieMnVmu1YP1RrngFgVQCyShuG9vm3ubaHvGZAnqsGxAA)を書いたら、別の先輩に『プロパティはデータ型じゃなくて値オブジェクトにしておいて』って言われたんです。何がダメなんですか？
さて、何がいけないのでしょう？

- データ型を使用していることで、validXXXなどのメソッドが必要になってしまっていること
- エンティティの作成時点で不正なエンティティが作成されることを許容する構成になっている
- Client側がHumanクラスに問い合わせをしないとHumanクラスが正常な状態か不正な状態かわからなくなっている。これによってClient側では結果を元に処理を継続できるかの判定を行う必要がでてきてしまい、ビジネスロジックが呼び出し側に書く必要が出てきてしまう
- 値オブジェクトを使うとそもそもエンティティの作成時点でValidかどうかを判定してエラーを返すことができるので、データ型をプロパティにするよりも堅牢にできる

### 課題2-4

先ほど新人エンジニアが作成した「Human」エンティティの各プロパティを値オブジェクトに置き換えてください。それぞれの値オブジェクトには以下のルールが存在します。

- ID：英数字のみ許容（!や$などの特殊記号は利用不可）
- 血液型：a,b,o,ab以外の値は設定できない
- 生年月日：20歳以上の生年月日しか設定できない
- 名前：20文字未満でなければいけない

```typescript
// 型定義
const humanIdBrand = Symbol('HumanId');
type HumanIdType = string & { [humanIdBrand]: unknown };

const bloodTypeBrand = Symbol('BloodType');
type BloodType = string & { [bloodTypeBrand]: unknown };

const birthDateBrand = Symbol('BirthDate');
type BirthDateType = Date & { [birthDateBrand]: unknown };

const nameBrand = Symbol('Name');
type NameType = string & { [nameBrand]: unknown };

// 値オブジェクト
class HumanId {
    private _value: HumanIdType;

    constructor(value: string) {
        if (!value) {
        throw new Error('IDは必須です');
        }
        
        const alphanumericRegex = /^[a-zA-Z0-9]+$/;
        if (!alphanumericRegex.test(value)) {
        throw new Error('IDは英数字のみ使用できます');
        }
        
        this._value = value as HumanIdType;
    }

    getValue(): HumanIdType {
        return this._value;
    }

    equals(other: HumanId): boolean {
        return this._value === other._value;
    }
}

class Blood {
    private readonly _value: BloodType;

    constructor(value: string) {
        const validBloodTypes = ['a', 'b', 'o', 'ab'];
        const normalizedType = value.toLowerCase().trim();
    
        if (!validBloodTypes.includes(normalizedType)) {
            throw new Error('血液型はa, b, o, abのいずれかである必要があります');
        }
    
        this._value = normalizedType as BloodType;
    }

    getValue(): BloodType {
        return this._value;
    }

    equals(other: Blood): boolean {
        return this._value === other._value;
    }
}


class BirthDate {
    private readonly _value: BirthDateType;

    constructor(value: Date | string) {
        const date = value instanceof Date ? value : new Date(value);
        
        if (isNaN(date.getTime())) {
            throw new Error('有効な日付を入力してください');
        }
        
        const today = new Date();
        const twentyYearsAgo = new Date(
            today.getFullYear() - 20,
            today.getMonth(),
            today.getDate()
        );
        
        if (date > twentyYearsAgo) {
            throw new Error('20歳以上である必要があります');
        }
        
        this._value = date as BirthDateType;
    }

    getValue(): BirthDateType {
        return this._value;
    }

    equals(other: BirthDate): boolean {
        return this._value === other._value;
    }
}


class Name {
    private readonly _value: NameType;

    constructor(value: string) {
        if (!value) {
            throw new InvalidNameError('名前は必須です');
        }
    
        const trimmedValue = value.trim();
        if (trimmedValue.length >= 20) {
            throw new InvalidNameError('名前は20文字未満である必要があります');
        }
        this._value = trimmedValue as NameType;
    }

    getValue(): NameType {
        return this._value;
    }

    equals(other: Name): boolean {
        return this._value === other._value;
    }
}

// エンティティ
class Human {
    private readonly _id: HumanId;
    private _bloodType: Blood;
    private _dateOfBirth: BirthDate;
    private _name: Name;

    private constructor(
        id: HumanId,
        bloodType: Blood,
        dateOfBirth: BirthDate,
        name: Name
    ) {
        this._id = id;
        this._bloodType = bloodType;
        this._dateOfBirth = dateOfBirth;
        this._name = name;
    }

    static to(
        id: string,
        name: string,
        bloodType: string,
        birthDate: Date | string
    ): Human {
        return new Human(
            new HumanIdVO(id),
            new NameVO(name),
            new BloodTypeVO(bloodType),
            new BirthDateVO(birthDate)
        );
    }
}
```

### メモ
- 言語として構造的型付けなので、単純にクラスと値だけでは、同一性の判定はできない(Nonimal Typing)。GoもTypescriptと同じ型の付け方。TypescriptでJavaとか同じようにNamed Typingしようと思うと個別に処理が必要になる。

- Branded Type
    - [Branded Type ベストプラクティス 検索](https://qiita.com/uhyo/items/de4cb2085fdbdf484b83)
    - [The Problem with TypeScript’s Structural Typing](https://effect.website/docs/code-style/branded-types/#the-problem-with-typescripts-structural-typing)
    - [TypeScript ⼩ネタとか](https://speakerdeck.com/sansantech/sansan-20230912-3)
    - あくまで、テクニックらしく、Typescriptが公式にだしているわけではないらしい。

- Parameter Properties
  - https://www.typescriptlang.org/docs/handbook/classes.html#parameter-properties
  - クラス定義を楽にかくやつ。慣れの問題なのか?一般的な書き方ではないので、ちょっと面食らう感じはある